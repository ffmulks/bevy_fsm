//! Procedural macros for `bevy_fsm`.
//!
//! This crate provides derive macros for finite state machine functionality:
//! - `#[derive(FSMTransition)]` - Default "allow all" transition implementation
//! - `#[derive(FSMState)]` - Generates variant-specific event triggering

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, Data, DeriveInput, Fields};

/// Converts `PascalCase` or `camelCase` to `snake_case`.
///
/// Handles acronyms gracefully: `FSMState` → `fsm_state`, `HTTPServer` → `http_server`
fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    let chars: Vec<char> = s.chars().collect();

    for (i, &ch) in chars.iter().enumerate() {
        if ch.is_uppercase() {
            let is_first = i == 0;
            let prev_is_lower = i > 0 && chars[i - 1].is_lowercase();
            let next_is_lower = i + 1 < chars.len() && chars[i + 1].is_lowercase();

            // Add underscore if:
            // 1. Previous char is lowercase (camelCase -> snake_case)
            // 2. This is uppercase, next is lowercase, and we're not first (handles acronyms)
            if !is_first && (prev_is_lower || next_is_lower) {
                result.push('_');
            }

            result.push(ch.to_lowercase().next().unwrap());
        } else {
            result.push(ch);
        }
    }
    result
}

/// Derive macro for generating a default `FSMTransition` implementation.
///
/// This macro generates a permissive `FSMTransition` implementation that allows all state
/// transitions. Use this for simple state machines where any transition should be allowed.
///
/// # Requirements
///
/// - Can be applied to any enum (doesn't require `EnumEvent` or `FSMState`)
/// - Depends on `bevy_fsm::FSMTransition` trait
///
/// # Generated Code
///
/// Generates an implementation of `FSMTransition` with `can_transition` always returning `true`.
///
/// # Example (Zero Boilerplate)
///
/// ```rust,ignore
/// use bevy::prelude::*;
/// use bevy_enum_event::EnumEvent;
/// use bevy_fsm::{FSMTransition, FSMState};
///
/// #[derive(Component, EnumEvent, FSMTransition, FSMState, Clone, Copy, Debug)]
/// enum GameState {
///     MainMenu,
///     Playing,
///     GameOver,
/// }
///
/// // All transitions are allowed automatically!
/// // MainMenu -> Playing ✅
/// // Playing -> GameOver ✅
/// // GameOver -> MainMenu ✅
/// ```
///
/// # Example (Custom Rules - Don't Derive)
///
/// If you need custom transition logic, don't derive `FSMTransition`:
///
/// ```rust,ignore
/// use bevy::prelude::*;
/// use bevy_enum_event::EnumEvent;
/// use bevy_fsm::{FSMTransition, FSMState};
///
/// // No FSMTransition derive here!
/// #[derive(Component, EnumEvent, FSMState, Clone, Copy, Debug)]
/// enum LifeFSM {
///     Alive,
///     Dying,
///     Dead,
/// }
///
/// // Manually implement for custom rules
/// impl FSMTransition for LifeFSM {
///     fn can_transition(from: Self, to: Self) -> bool {
///         matches!((from, to),
///             (LifeFSM::Alive, LifeFSM::Dying) |
///             (LifeFSM::Dying, LifeFSM::Dead)) || from == to
///     }
/// }
/// ```
///
/// # Panics
///
/// - Panics if applied to a non-enum type
#[proc_macro_derive(FSMTransition)]
pub fn derive_fsm_transition(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let enum_name = &input.ident;
    let generics = input.generics.clone();
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    // Verify it's an enum (though not strictly necessary for FSMTransition)
    assert!(
        matches!(&input.data, Data::Enum(_)),
        "FSMTransition can only be derived for enums"
    );

    let expanded = quote! {
        impl #impl_generics bevy_fsm::FSMTransition for #enum_name #ty_generics #where_clause {
            /// Default implementation: allows all transitions.
            ///
            /// This is auto-generated by `#[derive(FSMTransition)]`.
            fn can_transition(_from: Self, _to: Self) -> bool {
                true
            }
        }
    };

    TokenStream::from(expanded)
}

/// Derive macro for generating FSM state infrastructure.
///
/// This macro extends `EnumEvent` with finite state machine functionality by implementing
/// the `FSMState` trait with variant-specific event triggering. It must be used alongside
/// `#[derive(EnumEvent)]`.
///
/// # Requirements
///
/// - Must be applied to the same enum as `#[derive(EnumEvent)]`
/// - The enum must only have unit variants (no tuple or named fields)
/// - Depends on types from `bevy_fsm` crate: `Enter<T>`, `Exit<T>`, `Transition<F, T>`, `FSMState`
///
/// # Generated Code
///
/// For an enum named `MyFSM`, this generates:
///
/// 1. **`FSMState` implementation** with three methods:
///    - `trigger_enter_variant(ec, state)` - Fires `Enter<module::Variant>` events
///    - `trigger_exit_variant(ec, state)` - Fires `Exit<module::Variant>` events
///    - `trigger_transition_variant(ec, from, to)` - Fires `Transition<module::From, module::To>` events
///
/// # Example (Zero Boilerplate - All Transitions Allowed)
///
/// ```rust,ignore
/// use bevy::prelude::*;
/// use bevy_enum_event::EnumEvent;
/// use bevy_fsm::{FSMTransition, FSMState};
///
/// // Just two derives - no FSMTransition implementation needed!
/// #[derive(Component, EnumEvent, FSMTransition, FSMState, Clone, Copy, Debug, PartialEq, Eq, Hash)]
/// enum GameState {
///     MainMenu,
///     Playing,
///     GameOver,
/// }
///
/// // All transitions are allowed by default
/// // MainMenu -> Playing ✅
/// // Playing -> GameOver ✅
/// // GameOver -> MainMenu ✅ (even backwards transitions work!)
/// ```
///
/// # Example (Custom Transition Rules)
///
/// Override the default `FSMTransition` implementation to add custom rules:
///
/// ```rust,ignore
/// use bevy::prelude::*;
/// use bevy_enum_event::EnumEvent;
/// use bevy_fsm::{FSMTransition, FSMState};
///
/// #[derive(Component, EnumEvent, FSMState, Clone, Copy, Debug, PartialEq, Eq, Hash)]
/// enum LifeFSM {
///     Alive,
///     Dying,
///     Dead,
/// }
///
/// // Override the default to add custom transition rules
/// impl FSMTransition for LifeFSM {
///     fn can_transition(from: Self, to: Self) -> bool {
///         matches!((from, to),
///             (LifeFSM::Alive, LifeFSM::Dying) |
///             (LifeFSM::Dying, LifeFSM::Dead)) || from == to
///     }
/// }
///
/// // Now transitions are restricted:
/// // Alive -> Dying ✅
/// // Dying -> Dead ✅
/// // Dead -> Alive ❌ (blocked by custom rules)
/// ```
///
/// # Panics
///
/// - Panics if applied to a non-enum type
/// - Panics if any variant has fields (only unit variants are supported for FSM)
#[proc_macro_derive(FSMState)]
pub fn derive_fsm_state(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let enum_name = &input.ident;
    let generics = input.generics.clone();
    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();

    // Extract variants from enum
    let variants = match &input.data {
        Data::Enum(data_enum) => &data_enum.variants,
        _ => panic!("FSMState can only be derived for enums"),
    };

    // Verify all variants are unit variants
    for variant in variants {
        assert!(
            matches!(variant.fields, Fields::Unit),
            "FSMState enum variants must be unit variants (no fields). Variant '{}' has fields.",
            variant.ident
        );
    }

    let variant_idents: Vec<_> = variants.iter().map(|v| &v.ident).collect();

    // Generate the module name (same as EnumEvent uses)
    let module_name_str = to_snake_case(&enum_name.to_string());
    let fsm_module_name = syn::Ident::new(&module_name_str, enum_name.span());

    // Generate Enter event triggers for each variant
    let enter_triggers: Vec<_> = variant_idents
        .iter()
        .map(|variant| {
            let variant_ty = quote! { #fsm_module_name::#variant #ty_generics };
            quote! {
                #enum_name::#variant => {
                    commands.trigger(bevy_fsm::Enter::<#variant_ty> {
                        entity,
                        state: #variant_ty,
                    });
                }
            }
        })
        .collect();

    // Generate Exit event triggers for each variant
    let exit_triggers: Vec<_> = variant_idents
        .iter()
        .map(|variant| {
            let variant_ty = quote! { #fsm_module_name::#variant #ty_generics };
            quote! {
                #enum_name::#variant => {
                    commands.trigger(bevy_fsm::Exit::<#variant_ty> {
                        entity,
                        state: #variant_ty,
                    });
                }
            }
        })
        .collect();

    // Generate all pairs of transition types (N × N combinations)
    let mut transition_triggers = Vec::new();
    for from_variant in &variant_idents {
        for to_variant in &variant_idents {
            let from_ty = quote! { #fsm_module_name::#from_variant #ty_generics };
            let to_ty = quote! { #fsm_module_name::#to_variant #ty_generics };
            transition_triggers.push(quote! {
                (#enum_name::#from_variant, #enum_name::#to_variant) => {
                    commands.trigger(bevy_fsm::Transition::<#from_ty, #to_ty> {
                        entity,
                        from: #from_ty,
                        to: #to_ty,
                    });
                }
            });
        }
    }

    let expanded = quote! {
        // Implement the FSMState trait methods
        impl #impl_generics bevy_fsm::FSMState for #enum_name #ty_generics #where_clause {
            /// Triggers variant-specific Enter event.
            ///
            /// This method is generated by `#[derive(FSMState)]` and is used internally
            /// by the bevy_fsm framework to fire Enter events for specific state variants.
            fn trigger_enter_variant(commands: &mut bevy::prelude::Commands, entity: bevy::prelude::Entity, state: Self) {
                match state {
                    #(#enter_triggers)*
                }
            }

            /// Triggers variant-specific Exit event.
            ///
            /// This method is generated by `#[derive(FSMState)]` and is used internally
            /// by the bevy_fsm framework to fire Exit events for specific state variants.
            fn trigger_exit_variant(commands: &mut bevy::prelude::Commands, entity: bevy::prelude::Entity, state: Self) {
                match state {
                    #(#exit_triggers)*
                }
            }

            /// Triggers variant-specific Transition event.
            ///
            /// This method is generated by `#[derive(FSMState)]` and is used internally
            /// by the bevy_fsm framework to fire Transition events between specific state variants.
            fn trigger_transition_variant(commands: &mut bevy::prelude::Commands, entity: bevy::prelude::Entity, from: Self, to: Self) {
                match (from, to) {
                    #(#transition_triggers)*
                }
            }
        }
    };

    TokenStream::from(expanded)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_snake_case_conversion() {
        assert_eq!(to_snake_case("LifeFSM"), "life_fsm");
        assert_eq!(to_snake_case("PlayerState"), "player_state");
        assert_eq!(to_snake_case("HTTPServer"), "http_server");
        assert_eq!(to_snake_case("FSM"), "fsm");
        assert_eq!(to_snake_case("MyHTTPSConnection"), "my_https_connection");
    }
}
